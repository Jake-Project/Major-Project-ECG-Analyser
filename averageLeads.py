# -*- coding: utf-8 -*-
"""
Created on Wed May  1 22:17:24 2019
@author: Jake Newall

This file allows for the 8 ECG signals which are used to be averaged.
The file also allows for the averaging of electrical noise generated by muscles and the 
removal of baseline drift
"""

from signalProcessing import Util
import os # Needed for folders
from scipy.interpolate import interp1d # To allow for cubic interpolation of the running mean datapoints
import matplotlib.pyplot as plt # To plot Graphs of data
import numpy as np

# Class that finds the average of all of the ECG leads
# The class allows for:
#   The average of all 8 signals to be found 
#   The moving average of the signal to be calculated
#   The cubic interpolation of that moving average for a smooth moving average signal rather than square
#   The signal average to have the drift removed which makes the data more uniform
#   The averaging of muscle noise found in the signal
class SingleSignal:
    
    # Function that returns the averaged signal from all of the 8 ECG leads
    def createAveragedSignal(char_string):
        # print('This is the char array ' + str(char_string))
        total = 0.00
        # Split by the commas and retrieve data as an array to iterate through
        ecg_data_instance = char_string.split(",") 
        for x in range(1, 9): # Do not include first position in array because this data is not needed
            total += float(ecg_data_instance[x]) # Cast to float and add all of the data together
            # print(total)
        
        averaged_signal = total / 9
        # print("Averaged Signal: " + str(averaged_signal))
        return averaged_signal
    
    
    # Method that takes a mean after n amount of signals have been iterated through
    # This data can then be used with cubic interpolation to create a smooth curve which 
    # represents a running mean.
    # Amount of signals for mean to be calculated on (running_mean_max_datapoints) Should create
    # a whole number when 6000 is divided by it.
    def calculateRunningMean(averaged_signal_data, running_mean_max_datapoints):
        
        # Array to hold the running mean datapoints
        running_mean_datapoints = []
        
        # Variables to calculate the mean
        ecg_running_mean = 0.0
        ecg_running_mean_counter = 0
        
        # Run through all of the data in the averaged signal
        for data in averaged_signal_data:
            # Add 1 to the counter and add the averaged signal    
            ecg_running_mean += data
            ecg_running_mean_counter += 1
        
            # If we have enough datapoints, save the data to the array and reset the counter                
            if ecg_running_mean_counter == running_mean_max_datapoints:
                running_mean_datapoints.append(ecg_running_mean/ecg_running_mean_counter)
                ecg_running_mean = 0.0
                ecg_running_mean_counter = 0
      
        return running_mean_datapoints

        
    # Function to calculate the cubic spline interpolation of the running average sections of the signal
    # This function additionally averages out the muscle noise found in the data. 
    # To average muscle noise, we use linear interpolation instead
    def calculateInterpolation(averaged_signal_data, running_mean_datapoints, type_of_interpolation, 
                                                                           folder_location, file_name):
        print("Calculating the Cubic Interpolation of the running mean sections")
        
        y = []
        
        # For the amount of data points in our code
        for x in range(1, len(running_mean_datapoints) + 1):
            y.append(x)
        
        #print(len(running_mean_datapoints))
        #print(len(y))
        
        # X is horizontal (The data point included in the mean of data)
        # Y is vertical (The mean of data that we wish to look at)
        # This returns the interpolation function which we need to make use of
        interpolated_representation = interp1d(y, running_mean_datapoints, type_of_interpolation)
        
        # Create new values inbetween 1 and the length of the array.
        # Need to create 6000 values over all
        increment = (len(running_mean_datapoints) - 1) / 6000
        xnew = np.arange(1, len(running_mean_datapoints), increment)
        interpolated_data = interpolated_representation(xnew) 
        
        folder_to_save_to = ''
        
        # Set the name of the title dependant on what interpolation is used
        # In this software, cubic is used on the running mean
        if type_of_interpolation == 'cubic':
            plt.title('Cubicly Interpolated Running Mean Against Averaged ECG Signal', fontsize = 20)
            # Plot the data ready to be saved as a graph
            plt.plot(averaged_signal_data, 'b-', interpolated_data, 'r-')
            plt.legend(['Averaged ECG Signal', 'Cubic Interpolation Of Running Average Sections'], loc='best')
            # Set where the graph should be saved to
            folder_to_save_to = folder_location +'/Graphs/Part 1 - (Running Mean Cubic Interpolation Paired With Averaged Signal Data)/'
            
        # Linear is used to average out muscle noise
        elif type_of_interpolation == 'linear':
            plt.title('Averaged ECG Signal With Noise Averaged Out By Linear Interpolation', fontsize = 20)
            # Plot the data ready to be saved as a graph
            plt.plot(averaged_signal_data, 'b-')
            plt.legend(['Averaged ECG Signal'], loc='best')
            # Set where the graph should be saved to
            folder_to_save_to = folder_location +'/Graphs/Part 3 - (ECG Signal with drift and muscular noise removed)/'
        
        # Save the graph to the correct directory
        Graph.saveGraph(folder_to_save_to, file_name)

        return interpolated_data 
      

    # Function that will eliminate baseline drift of the biological ECG signal
    def removeDrift(averaged_ecg_data, running_mean_datapoints, mean_of_data_before_drift_removal, 
                                                                        folder_location, file_name):
        
        # Array to contain all of the data with the frigy removed
        ecg_signal_with_drift_removed = []
        print('\nLength of averaged data = ' + str(len(averaged_ecg_data)) + '. Length of running mean datapoints' + str(len(running_mean_datapoints)))
        counter = 0

        # Iterate through all the data in running mean datapoints
        for data in running_mean_datapoints:
            
            # Calculate the distance between the running mean datapoints and 0.
            # Remove this distance from the averaged ECG data to remove baseline drift
            ecg_signal_with_drift_removed.append(averaged_ecg_data[counter] - Util.findDistance(0, data))
            counter += 1
        
        # Recalculate the mean of data to be displayed on a graph
        mean_of_data_now = Util.calculateMeanOfData(ecg_signal_with_drift_removed)
        
        # Set the graph title and plot the data
        plt.title('Averaged ECG Signal Plotted Against ECG Signal With Drift Removed', fontsize = 20)
        plt.plot(ecg_signal_with_drift_removed, '-', mean_of_data_before_drift_removal, '-', mean_of_data_now, '-', averaged_ecg_data, '-')
        plt.legend(['Averaged ECG Data - Drift Removed', 'Mean Of Data Before Drift Removal', 'Mean Of Data Now', 'Averaged ECG Data - No Processing'], loc='best')
        
        # Set the folder of which to save the graph to and save the graph
        folder_to_save_to = folder_location +'/Graphs/Part 2 - (Averaged ECG Data (Drift Removed Vs No Processing)/'
        Graph.saveGraph(folder_to_save_to, file_name)
        
        return ecg_signal_with_drift_removed
    
    #__init__.py

class Graph:
    
        # Function to make a directory in python to save the graphs to.
        # This is the same function as the one in signalProcessing.py
        # This is due to the fact that the data is plotted in the function that calls this function.
        # If another file is used to attempt to save a graph, no data is shown on the graph
    def saveGraph(folder_to_save_to, file_name):
        # Attempt to create a folder and save to it. If folder already exists, save to it.
        try:
            os.mkdir(folder_to_save_to)
            print('The Directory: ' + folder_to_save_to + ' Has Been Created. Saving Data')
        except:
            print('The Directory: ' + folder_to_save_to + ' Already Exists. Saving Data')
            
        # Set X and Y Labels on the plot
        plt.xlabel('Time in 600ths of a second', fontsize = 14)
        plt.ylabel('Amplitude in Mv (Millivolts)', fontsize = 14)
        
        # Save and clear the plot
        # bbox_inches = "tight" is to make sure that the whole of the graph fits within the image
        plt.savefig(folder_to_save_to + file_name + '.png', bbox_inches = "tight")
        plt.cla() # Clear the plot
        